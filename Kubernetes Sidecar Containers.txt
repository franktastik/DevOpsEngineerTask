

We have a web server container running the nginx image. The access and error logs generated by the web server are not critical enough to be placed on a persistent volume. However, Nautilus developers need access to the last 24 hours of logs so that they can trace issues and bugs. Therefore, we need to ship the access and error logs for the web server to a log-aggregation service. Following the separation of concerns principle, we implement the Sidecar pattern by deploying a second container that ships the error and access logs from nginx. Nginx does one thing, and it does it well—serving web pages. The second container also specializes in its task—shipping logs. Since containers are running on the same Pod, we can use a shared emptyDir volume to read and write logs.

Create a pod named webserver.

Create an emptyDir volume shared-logs.

Create two containers from nginx and ubuntu images with latest tag only and remember to mention tag i.e nginx:latest, nginx container name should be nginx-container and ubuntu container name should be sidecar-container on webserver pod.

Add command on sidecar-container "sh","-c","while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"

Mount the volume shared-logs on both containers at location /var/log/nginx, all containers should be up and running.

Note: The kubectl utility on jump_host has been configured to work with the kubernetes cluster.


#SOLUTION

N.B: Indentation trick = volumes and containers keyword are top level. Others are sub level with 2 tabs(keyboard) under the main top levels. 

#Create a yaml file using the command below 
    vi pod.yaml

# A. Add a pod definition file with the name of the pod 

# Save the file 

# Run the kubectl command below 
    kubectl create -f pod.yaml

# If you are updating a yaml file, use the command below 
    kubectl apply -f pod.yaml

# Check the pod
    kubectl get po 





yaml file to add in pod.yaml
--------------------

apiVersion: v1
kind: Pod
metadata:
  name: webserver
  labels:
    name: webserver
spec:
  volumes:
    - name: nginx
        emptyDir: {}
  containers:
    - name: nginx-container 
      image: nginx:latest
      volumeMounts:
        - mountPath: /var/log/nginx 
          name: shared-logs
    - name: sidecar-container
      image: ubuntu:latest
      command:
        [
          "/bin/bash",
          "-c",
          "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"
        ]
      volumeMounts:
        - mountPath: /var/log/nginx 
          name: shared-logs


apiVersion: v1
kind: Pod
metadata:
  name: webserver
  labels:
    name: webserver
spec:
  volumes:
    - name: shared-logs
      emptyDir: {}
  containers:
    - name: nginx-container
      image: nginx:latest
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx
    - name: sidecar-container
      image: ubuntu:latest
      command:
        [
          "/bin/bash",
          "-c",
          "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done",
        ]
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx   








#References
https://www.youtube.com/watch?v=6G7eaA7-RFA 
https://www.youtube.com/watch?v=BEcvPJ5oSCA 
https://kubernetes.io/docs/concepts/cluster-administration/logging/ 
https://banzaicloud.com/blog/k8s-sidecars/
https://medium.com/bb-tutorials-and-thoughts/kubernetes-learn-sidecar-container-pattern-6d8c21f873d
https://kubernetes-csi.github.io/docs/sidecar-containers.html 

#Note
Use of the sidecar containers is strictly optional, but highly recommended.

The most common sidecar containers are logging utilities, sync services, watchers and monitoring agents. 

You can use a sidecar container in one of the following ways:

The sidecar container streams application logs to its own stdout.
The sidecar container runs a logging agent, which is configured to pick up logs from an application container.

Benefits of these sidecar containers include:

Reduction of "boilerplate" code.
CSI Driver developers do not have to worry about complicated, "Kubernetes specific" code.
Separation of concerns.
Code that interacts with the Kubernetes API is isolated from (and in a different container then) the code that implements the CSI interface.

Pros of sidecar
- Decoupling thick libraries and References
- Applications can evolve independently 
- Polyglot - Each sidecar application can be written in its own language
Cons of sidecar
- Latency 
- Complexity. 
